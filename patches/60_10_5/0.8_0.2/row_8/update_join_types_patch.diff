--- a/decoupled/60/0.8_0.2/8/django_django/django/db/models/sql/query.py
+++ b/decoupled/60/0.8_0.2/8/django_django/django/db/models/sql/query.py
@@ -2245,58 +2245,61 @@
         """

         self.votes.update(votes)

 

-    def update_join_types(self, query):

-        """

-        Change join types so that the generated query is as efficient as

-        possible, but still correct. So, change as many joins as possible

-        to INNER, but don't make OUTER joins INNER if that could remove

-        results from the query.

-        """

-        to_promote = set()

-        to_demote = set()

-        # The effective_connector is used so that NOT (a AND b) is treated

-        # similarly to (a OR b) for join promotion.

-        for table, votes in self.votes.items():

-            # We must use outer joins in OR case when the join isn't contained

-            # in all of the joins. Otherwise the INNER JOIN itself could remove

-            # valid results. Consider the case where a model with rel_a and

-            # rel_b relations is queried with rel_a__col=1 | rel_b__col=2. Now,

-            # if rel_a join doesn't produce any results is null (for example

-            # reverse foreign key or null value in direct foreign key), and

-            # there is a matching row in rel_b with col=2, then an INNER join

-            # to rel_a would remove a valid match from the query. So, we need

-            # to promote any existing INNER to LOUTER (it is possible this

-            # promotion in turn will be demoted later on).

-            if self.effective_connector == 'OR' and votes < self.num_children:

-                to_promote.add(table)

-            # If connector is AND and there is a filter that can match only

-            # when there is a joinable row, then use INNER. For example, in

-            # rel_a__col=1 & rel_b__col=2, if either of the rels produce NULL

-            # as join output, then the col=1 or col=2 can't match (as

-            # NULL=anything is always false).

-            # For the OR case, if all children voted for a join to be inner,

-            # then we can use INNER for the join. For example:

-            #     (rel_a__col__icontains=Alex | rel_a__col__icontains=Russell)

-            # then if rel_a doesn't produce any rows, the whole condition

-            # can't match. Hence we can safely use INNER join.

-            if self.effective_connector == 'AND' or (

-                    self.effective_connector == 'OR' and votes == self.num_children):

-                to_demote.add(table)

-            # Finally, what happens in cases where we have:

-            #    (rel_a__col=1|rel_b__col=2) & rel_a__col__gte=0

-            # Now, we first generate the OR clause, and promote joins for it

-            # in the first if branch above. Both rel_a and rel_b are promoted

-            # to LOUTER joins. After that we do the AND case. The OR case

-            # voted no inner joins but the rel_a__col__gte=0 votes inner join

-            # for rel_a. We demote it back to INNER join (in AND case a single

-            # vote is enough). The demotion is OK, if rel_a doesn't produce

-            # rows, then the rel_a__col__gte=0 clause can't be true, and thus

-            # the whole clause must be false. So, it is safe to use INNER

-            # join.

-            # Note that in this example we could just as well have the __gte

-            # clause and the OR clause swapped. Or we could replace the __gte

-            # clause with an OR clause containing rel_a__col=1|rel_a__col=2,

-            # and again we could safely demote to INNER.

-        query.promote_joins(to_promote)

-        query.demote_joins(to_demote)

-        return to_demote

+def update_join_types(self, query):

+    """

+    Change join types so that the generated query is as efficient as

+    possible, but still correct. So, change as many joins as possible

+    to INNER, but don't make OUTER joins INNER if that could remove

+    results from the query.

+    """

+    to_promote = set()

+    to_demote = set()

+    # The effective_connector is used so that NOT (a AND b) is treated

+    # similarly to (a OR b) for join promotion.

+    for table, votes in self.votes.items():

+        # We must use outer joins in OR case when the join isn't contained

+        # in all of the joins. Otherwise the INNER JOIN itself could remove

+        # valid results. Consider the case where a model with rel_a and

+        # rel_b relations is queried with rel_a__col=1 | rel_b__col=2. Now,

+        # if rel_a join doesn't produce any results is null (for example

+        # reverse foreign key or null value in direct foreign key), and

+        # there is a matching row in rel_b with col=2, then an INNER join

+        # to rel_a would remove a valid match from the query. So, we need

+        # to promote any existing INNER to LOUTER (it is possible this

+        # promotion in turn will be demoted later on).

+        if self.effective_connector == 'OR' and votes < self.num_children:

+            to_promote.add(table)

+        # If connector is AND and there is a filter that can match only

+        # when there is a joinable row, then use INNER. For example, in

+        # rel_a__col=1 & rel_b__col=2, if either of the rels produce NULL

+        # as join output, then the col=1 or col=2 can't match (as

+        # NULL=anything is always false).

+        # For the OR case, if all children voted for a join to be inner,

+        # then we can use INNER for the join. For example:

+        #     (rel_a__col__icontains=Alex | rel_a__col__icontains=Russell)

+        # then if rel_a doesn't produce any rows, the whole condition

+        # can't match. Hence we can safely use INNER join.

+        if self.effective_connector == 'AND' or (

+                self.effective_connector == 'OR' and votes == self.num_children):

+            to_demote.add(table)

+        # Finally, what happens in cases where we have:

+        #    (rel_a__col=1|rel_b__col=2) & rel_a__col__gte=0

+        # Now, we first generate the OR clause, and promote joins for it

+        # in the first if branch above. Both rel_a and rel_b are promoted

+        # to LOUTER joins. After that we do the AND case. The OR case

+        # voted no inner joins but the rel_a__col__gte=0 votes inner join

+        # for rel_a. We demote it back to INNER join (in AND case a single

+        # vote is enough). The demotion is OK, if rel_a doesn't produce

+        # rows, then the rel_a__col__gte=0 clause can't be true, and thus

+        # the whole clause must be false. So, it is safe to use INNER

+        # join.

+        # Note that in this example we could just as well have the __gte

+        # clause and the OR clause swapped. Or we could replace the __gte

+        # clause with an OR clause containing rel_a__col=1|rel_a__col=2,

+        # and again we could safely demote to INNER.

+    # Fix for the issue with multiline RawSQL in order_by clause

+    sql_oneline = ' '.join(query.order_by.split('\n'))

+    query.order_by = sql_oneline

+    query.promote_joins(to_promote)

+    query.demote_joins(to_demote)

+    return to_demote
