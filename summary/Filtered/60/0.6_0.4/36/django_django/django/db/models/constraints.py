from django.db.models.query_utils import Q
from django.db.models.sql.query import Query

__all__ = ['CheckConstraint', 'UniqueConstraint']


class BaseConstraint:
    def __init__(self, name):
        self.name = name

    def constraint_sql(self, model, schema_editor):
        raise NotImplementedError('This method must be implemented by a subclass.')

    def create_sql(self, model, schema_editor):
        raise NotImplementedError('This method must be implemented by a subclass.')

    def remove_sql(self, model, schema_editor):
        raise NotImplementedError('This method must be implemented by a subclass.')

    def deconstruct(self):
        """
        Deconstructs a model constraint into a path, args, and kwargs.
        
        This function is used to serialize a model constraint into a form that can be
        reconstructed later. It returns a tuple containing the path to the constraint
        class, an empty tuple for arguments, and a dictionary with the constraint's
        name.
        
        Parameters:
        self (Constraint): The constraint object to deconstruct.
        
        Returns:
        tuple: A tuple containing the path to the constraint class, an empty tuple,
        and a
        """

        path = '%s.%s' % (self.__class__.__module__, self.__class__.__name__)
        path = path.replace('django.db.models.constraints', 'django.db.models')
        return (path, (), {'name': self.name})

    def clone(self):
        _, args, kwargs = self.deconstruct()
        return self.__class__(*args, **kwargs)


class CheckConstraint(BaseConstraint):
    def __init__(self, *, check, name):
        """
        Initialize a CheckConstraint instance.
        
        This method sets up a CheckConstraint object with the provided check and name.
        
        Parameters:
        check (Q instance or boolean expression): The condition that the model
        must satisfy. This should be a Django Q instance or a boolean
        expression.
        name (str): A name for the constraint, which can be used for
        documentation or debugging purposes.
        
        Raises:
        TypeError: If the provided check is not a Q instance or boolean
        expression.
        
        Example
        """

        self.check = check
        if not getattr(check, 'conditional', False):
            raise TypeError(
                'CheckConstraint.check must be a Q instance or boolean '
                'expression.'
            )
        super().__init__(name)

    def _get_check_sql(self, model, schema_editor):
        query = Query(model=model, alias_cols=False)
        where = query.build_where(self.check)
        compiler = query.get_compiler(connection=schema_editor.connection)
        sql, params = where.as_sql(compiler, schema_editor.connection)
        return sql % tuple(schema_editor.quote_value(p) for p in params)

    def constraint_sql(self, model, schema_editor):
        check = self._get_check_sql(model, schema_editor)
        return schema_editor._check_sql(self.name, check)

    def create_sql(self, model, schema_editor):
        check = self._get_check_sql(model, schema_editor)
        return schema_editor._create_check_sql(model, self.name, check)

    def remove_sql(self, model, schema_editor):
        return schema_editor._delete_check_sql(model, self.name)

    def __repr__(self):
        return "<%s: check='%s' name=%r>" % (self.__class__.__name__, self.check, self.name)

    def __eq__(self, other):
        """
        __eq__(self, other)
        
        Compares the current CheckConstraint instance with another object.
        
        Parameters:
        - other (CheckConstraint): The other CheckConstraint instance to compare with.
        
        Returns:
        - bool: True if the current instance and the other instance have the same name and check, False otherwise.
        
        Note:
        - If the other object is not an instance of CheckConstraint, the comparison is delegated to the superclass's __eq__ method.
        """

        if isinstance(other, CheckConstraint):
            return self.name == other.name and self.check == other.check
        return super().__eq__(other)

    def deconstruct(self):
        path, args, kwargs = super().deconstruct()
        kwargs['check'] = self.check
        return path, args, kwargs


class UniqueConstraint(BaseConstraint):
    def __init__(self, *, fields, name, condition=None):
        if not fields:
            raise ValueError('At least one field is required to define a unique constraint.')
        if not isinstance(condition, (type(None), Q)):
            raise ValueError('UniqueConstraint.condition must be a Q instance.')
        self.fields = tuple(fields)
        self.condition = condition
        super().__init__(name)

    def _get_condition_sql(self, model, schema_editor):
        if self.condition is None:
            return None
        query = Query(model=model, alias_cols=False)
        where = query.build_where(self.condition)
        compiler = query.get_compiler(connection=schema_editor.connection)
        sql, params = where.as_sql(compiler, schema_editor.connection)
        return sql % tuple(schema_editor.quote_value(p) for p in params)

    def constraint_sql(self, model, schema_editor):
        """
        Generates a SQL constraint for a Django model.
        
        This function is used to create a unique constraint on specified fields in a Django model. It constructs the necessary SQL command to enforce uniqueness based on the provided fields and any additional conditions.
        
        Parameters:
        model (django.db.models.Model): The Django model class to which the constraint will be applied.
        schema_editor (django.db.backends.base.schema.BaseSchemaEditor): The schema editor object used to execute the SQL command.
        
        Returns:
        str: The SQL command
        """

        fields = [model._meta.get_field(field_name).column for field_name in self.fields]
        condition = self._get_condition_sql(model, schema_editor)
        return schema_editor._unique_sql(model, fields, self.name, condition=condition)

    def create_sql(self, model, schema_editor):
        """
        Generates a SQL statement to create a unique constraint on a model's fields.
        
        This function is used to create a unique constraint in a database for a specified model. It takes the model and a schema editor as inputs and constructs the necessary SQL command.
        
        Parameters:
        model (django.db.models.Model): The Django model on which the unique constraint will be created.
        schema_editor (django.db.backends.base.schema.BaseSchemaEditor): The schema editor used to generate the SQL.
        
        Returns:
        str: A
        """

        fields = [model._meta.get_field(field_name).column for field_name in self.fields]
        condition = self._get_condition_sql(model, schema_editor)
        return schema_editor._create_unique_sql(model, fields, self.name, condition=condition)

    def remove_sql(self, model, schema_editor):
        condition = self._get_condition_sql(model, schema_editor)
        return schema_editor._delete_unique_sql(model, self.name, condition=condition)

    def __repr__(self):
        return '<%s: fields=%r name=%r%s>' % (
            self.__class__.__name__, self.fields, self.name,
            '' if self.condition is None else ' condition=%s' % self.condition,
        )

    def __eq__(self, other):
        if isinstance(other, UniqueConstraint):
            return (
                self.name == other.name and
                self.fields == other.fields and
                self.condition == other.condition
            )
        return super().__eq__(other)

    def deconstruct(self):
        path, args, kwargs = super().deconstruct()
        kwargs['fields'] = self.fields
        if self.condition:
            kwargs['condition'] = self.condition
        return path, args, kwargs
