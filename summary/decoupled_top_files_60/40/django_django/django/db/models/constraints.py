from django.db.models.query_utils import Q
from django.db.models.sql.query import Query

__all__ = ['CheckConstraint', 'UniqueConstraint']


class BaseConstraint:
    def __init__(self, name):
        self.name = name

    def constraint_sql(self, model, schema_editor):
        raise NotImplementedError('This method must be implemented by a subclass.')

    def create_sql(self, model, schema_editor):
        raise NotImplementedError('This method must be implemented by a subclass.')

    def remove_sql(self, model, schema_editor):
        raise NotImplementedError('This method must be implemented by a subclass.')

    def deconstruct(self):
        """
        Deconstructs a model constraint into a path, arguments, and keyword arguments.
        
        This function is used to serialize a model constraint object into a format that can be used to reconstruct the object later. The function returns a tuple containing the path to the constraint class, an empty tuple for arguments, and a dictionary with the constraint's name.
        
        Parameters:
        self (Constraint): The model constraint object to deconstruct.
        
        Returns:
        tuple: A tuple containing the path to the constraint class, an empty tuple
        """

        path = '%s.%s' % (self.__class__.__module__, self.__class__.__name__)
        path = path.replace('django.db.models.constraints', 'django.db.models')
        return (path, (), {'name': self.name})

    def clone(self):
        _, args, kwargs = self.deconstruct()
        return self.__class__(*args, **kwargs)


class CheckConstraint(BaseConstraint):
    def __init__(self, *, check, name):
        self.check = check
        if not getattr(check, 'conditional', False):
            raise TypeError(
                'CheckConstraint.check must be a Q instance or boolean '
                'expression.'
            )
        super().__init__(name)

    def _get_check_sql(self, model, schema_editor):
        query = Query(model=model, alias_cols=False)
        where = query.build_where(self.check)
        compiler = query.get_compiler(connection=schema_editor.connection)
        sql, params = where.as_sql(compiler, schema_editor.connection)
        return sql % tuple(schema_editor.quote_value(p) for p in params)

    def constraint_sql(self, model, schema_editor):
        check = self._get_check_sql(model, schema_editor)
        return schema_editor._check_sql(self.name, check)

    def create_sql(self, model, schema_editor):
        check = self._get_check_sql(model, schema_editor)
        return schema_editor._create_check_sql(model, self.name, check)

    def remove_sql(self, model, schema_editor):
        return schema_editor._delete_check_sql(model, self.name)

    def __repr__(self):
        return "<%s: check='%s' name=%r>" % (self.__class__.__name__, self.check, self.name)

    def __eq__(self, other):
        if isinstance(other, CheckConstraint):
            return self.name == other.name and self.check == other.check
        return super().__eq__(other)

    def deconstruct(self):
        """
        Deconstructs the current object into its component parts for serialization or migration purposes.
        
        This method is typically used in Django models to serialize the object's state for storage or transmission. It extracts the path, arguments, and keyword arguments of the object, and adds a custom keyword argument 'check' which is used to specify a condition or validation check.
        
        Args:
        None (This method is called internally by Django and does not accept any parameters).
        
        Returns:
        tuple: A tuple containing three elements:
        """

        path, args, kwargs = super().deconstruct()
        kwargs['check'] = self.check
        return path, args, kwargs


class UniqueConstraint(BaseConstraint):
    def __init__(self, *, fields, name, condition=None):
        if not fields:
            raise ValueError('At least one field is required to define a unique constraint.')
        if not isinstance(condition, (type(None), Q)):
            raise ValueError('UniqueConstraint.condition must be a Q instance.')
        self.fields = tuple(fields)
        self.condition = condition
        super().__init__(name)

    def _get_condition_sql(self, model, schema_editor):
        """
        Generates a SQL condition string for a given model.
        
        This method constructs a SQL WHERE clause based on a provided condition and returns it as a string. The condition is expected to be a query condition that can be processed by the Query class.
        
        Parameters:
        model (django.db.models.Model): The Django model class for which the SQL condition is being generated.
        schema_editor (django.db.migrations.operations.base.Operation): The schema editor used to quote values properly.
        
        Returns:
        str: The SQL WHERE
        """

        if self.condition is None:
            return None
        query = Query(model=model, alias_cols=False)
        where = query.build_where(self.condition)
        compiler = query.get_compiler(connection=schema_editor.connection)
        sql, params = where.as_sql(compiler, schema_editor.connection)
        return sql % tuple(schema_editor.quote_value(p) for p in params)

    def constraint_sql(self, model, schema_editor):
        fields = [model._meta.get_field(field_name).column for field_name in self.fields]
        condition = self._get_condition_sql(model, schema_editor)
        return schema_editor._unique_sql(model, fields, self.name, condition=condition)

    def create_sql(self, model, schema_editor):
        fields = [model._meta.get_field(field_name).column for field_name in self.fields]
        condition = self._get_condition_sql(model, schema_editor)
        return schema_editor._create_unique_sql(model, fields, self.name, condition=condition)

    def remove_sql(self, model, schema_editor):
        condition = self._get_condition_sql(model, schema_editor)
        return schema_editor._delete_unique_sql(model, self.name, condition=condition)

    def __repr__(self):
        """
        This function returns a string representation of the object. The string includes the class name, fields, name, and condition (if any). The key parameters are:
        - self: The object instance.
        - fields: A list of fields.
        - name: The name of the object.
        - condition: An optional condition.
        
        The output is a formatted string that provides a clear representation of the object's state.
        """

        return '<%s: fields=%r name=%r%s>' % (
            self.__class__.__name__, self.fields, self.name,
            '' if self.condition is None else ' condition=%s' % self.condition,
        )

    def __eq__(self, other):
        if isinstance(other, UniqueConstraint):
            return (
                self.name == other.name and
                self.fields == other.fields and
                self.condition == other.condition
            )
        return super().__eq__(other)

    def deconstruct(self):
        """
        Deconstructs the current object into its component parts for serialization.
        
        This method is used to break down the object into a path, arguments, and keyword arguments, which can be used to reconstruct the object later. The original deconstruction process is extended to include additional fields and a condition.
        
        Args:
        None (This method is called automatically when needed, such as during serialization).
        
        Returns:
        tuple: A tuple containing:
        - str: The path to the object's class.
        - list:
        """

        path, args, kwargs = super().deconstruct()
        kwargs['fields'] = self.fields
        if self.condition:
            kwargs['condition'] = self.condition
        return path, args, kwargs
